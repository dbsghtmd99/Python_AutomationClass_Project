<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Python_AutomationClass_Project</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="pythonautomationclassproject">Python_AutomationClass_Project</h1>
<h2 id="2018270819-%ec%9c%a4%ed%98%b8%ec%8a%b9-%ec%9e%91%ec%84%b1">2018270819 윤호승 작성</h2>
<p>이 문서는 파이썬 자동화 교육의 최종 프로젝트에 대한 보고서이다.</p>
<p>소스 코드는 <a href="https://github.com/dbsghtmd99/Python_AutomationClass_Project">https://github.com/dbsghtmd99/Python_AutomationClass_Project</a> 에서 확인 가능하다.</p>
<h2 id="1-%ea%b0%9c%ec%9a%94-%eb%b0%8f-%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac">1. 개요 및 작동 원리</h2>
<p>유튜브의 재생목록, 채널의 주소만 입력하면 재생목록의 모든영상 또는 채널의 모든 영상을 .mp4 파일로 다운로드 받을 수 있다.</p>
<p>작동 원리는 beautifulSoup 라이브러리로부터  parsing 해온 html 정보를 분석하여 동영상의 url정보를 얻어낸 후, 유튜브 동영상을 다운로드 해주는 모듈에 적용하여 .mp4 파일로 다운로드 되는 방식이다.</p>
<h2 id="2-%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ec%84%a4%eb%aa%85">2. 프로젝트 설명</h2>
<h3 id="21-%ea%b0%9c%eb%b0%9c-%ed%99%98%ea%b2%bd-%eb%b0%8f-%ec%9a%94%ea%b5%ac-%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac">2.1. 개발 환경 및 요구 라이브러리</h3>
<p>코드를 실행시키기 전, Anaconda Prompt 를 실행시켜 다음의 라이브러리를 설치해야 한다.</p>
<ul>
<li>bs4 : html parsing 기능 제공 (beautifulSoup)</li>
<li><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a> : 유튜브 링크를 통한 다운로드 기능 제공</li>
<li><s>selenium</s></li>
</ul>
<p>Python 내장 모듈은 다음과 같다.</p>
<ul>
<li>os : 새로운 폴더생성, 디렉토리 지정기능 제공</li>
<li>shitil : 다운로드된 파일을 이동시켜주는 기능 제공</li>
<li>datetime : 현재 시간정보를 불러와 다운로드된 파일을 이동시킬 폴더의 이름을 설정하는 기능 제공</li>
</ul>
<p>또한 다음과 같은 환경에서 정상 작동을 확인하였다.</p>
<ul>
<li>conda 4.7.12</li>
<li>Python 3.7</li>
</ul>
<h3 id="22-%ec%9c%a0%ed%8a%9c%eb%b8%8c%ec%9d%98-%eb%a7%81%ed%81%ac-%ea%b5%ac%ec%a1%b0%ec%97%90-%eb%8c%80%ed%95%9c-%ec%9d%b4%ed%95%b4">2.2. 유튜브의 링크 구조에 대한 이해</h3>
<p>이 부분에서는 현재 유튜브가 가지고 있는 Url 구조에 대해 알아볼 것이다.</p>
<h4 id="221-%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%eb%8f%99%ec%98%81%ec%83%81-url">2.2.1. 일반적인 동영상 Url</h4>
<p>일반적으로 유튜브 Url을 복사하면 다음과 같은 형태일 것이다.
<a href="https://www.youtube.com/watch?v=UuV2BmJ1p_I">https://www.youtube.com/watch?v=UuV2BmJ1p_I</a></p>
<p>즉 , <a href="https://www.youtube.com">https://www.youtube.com</a> 에 /watch?v=UuV2BmJ1p_I 라는 해당 동영상의 고유한 ID를 추가시켜 해당 영상으로 이동되는 방식이다.</p>
<p>좀 더 자세하게 이러한 동영상들의 정보가 여러개 있는 재생목록이나 유튜브 채널에 대해서도 알아보자.</p>
<h4 id="222-%ec%9e%ac%ec%83%9d%eb%aa%a9%eb%a1%9d%ec%9d%98-url">2.2.2. 재생목록의 Url</h4>
<p>재생목록의 경우 복사된 Url 을 확인 해보면 다음과 같다.</p>
<p><a href="https://www.youtube.com/playlist?list=PLwpDa9WrkRDRXRidbaSoWaXecj1BzFIbJ">https://www.youtube.com/playlist?list=PLwpDa9WrkRDRXRidbaSoWaXecj1BzFIbJ</a></p>
<p>마찬가지로 <a href="https://www.youtube.com/playlist?list=">https://www.youtube.com/playlist?list=</a> 에 재생목록의 고유 ID 가 추가되어 해당 재생목록으로 이동 될 수 있다.</p>
<h4 id="223-%ec%b1%84%eb%84%90">2.2.3. 채널</h4>
<p>유튜브 채널의 링크는 보통 다음과 같은 형식이다.</p>
<p><a href="https://www.youtube.com/channel/UCtckgmUcpzqGnzcs7xEqMzQ">https://www.youtube.com/channel/UCtckgmUcpzqGnzcs7xEqMzQ</a> 또는</p>
<p><a href="https://www.youtube.com/user/SMTOWN">https://www.youtube.com/user/SMTOWN</a></p>
<p>첫 번째의 경우는 쉽게 채널의 ID가 무엇인지 눈치 챌 수 있을 것이다.</p>
<p>그러나 실제 채널의 ID는 UCtckgmUcpzqGnzcs7xEqMzQ 가 아닌 tckgmUcpzqGnzcs7xEqMzQ 인데, (UC가 제외되었다.) UC 란 아마도 UserChannel 의 약자인 것 같고, 여러 채널들을 돌아다니며 채널 주소와 재생목록의 주소를 비교하여 이고 UC 다음의 문자열이 실제 채널의 ID로 표현되는 규칙을 찾아내었다.</p>
<p>두 번째의 경우는 채널의 고유한 ID가 숨겨져 있다.</p>
<p>보통 소속사 대표 채널이나 뉴스 채널 등 대규모 채널의 경우 이러한 방식으로 Utl을 표시한다. 때문에 html 정보를 분석해서 숨겨진 고유ID를 찾아야한다.</p>
<p>이 방법에 대해서는 2.3.2. 의 findUrlFromUser() 메소드의 설명에서 더 자세히 다룰 것이다.</p>
<p>실제로 위의 메소드를 실행시키면 UCEf_Bc-KVd7onSeifS3py9g 라는 값을 찾아낼 수 있다. 이것은 <a href="https://www.youtube.com/channel/UCEf_Bc-KVd7onSeifS3py9g">https://www.youtube.com/channel/UCEf_Bc-KVd7onSeifS3py9g</a> 라는 url은 <a href="https://www.youtube.com/user/SMTOWN">https://www.youtube.com/user/SMTOWN</a> 와 SMTOWN 이라는 같은 채널을 보여준다는 말과 같고, 실제로 직접 접속하면 똑같은 창을 로드하는 것을 확인해 볼 수 있다.</p>
<p>또한 마찬가지로, 실제 채널의 ID 는 앞의 UC를 제외한 Ef_Bc-KVd7onSeifS3py9g 이다.</p>
<p>유튜브에서는 채널이 업로드한 모든 동영상을 하나의 재생목록을 만들어 재생 시켜주는 기능이 제공된다. 채널의 홈 화면에 나와있는 '업로드한 동영상 &gt; 모두 재생'이 이 기능을 수행한다.</p>
<p>다음의 사진들은 여러 채널들을 방문하여 '모두 재생'의 버튼에 마우스 커서를 갖다댄 후 이 버튼의 링크를 파란색 네모박스로 표시해둔 사진이다. 파란색 네모박스 안의 빨간색 네모박스와 채널의 Url의 빨간색 네모박스를 비교해보자.</p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\1.png" alt="1"></p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\2.png" alt="2"></p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\3.png" alt="3"></p>
<p>이 외에도 수많은 채널들을 방문해본 결과, 채널의 Url이 UC + '채널의 고유ID' 라고 표현되듯 '업로드한 동영상 모두 재생'의 기능을 수행하는 Url은 모두 다음과 같은 형식의 Url으로 구성되었다.</p>
<blockquote>
<p>UC + '채널의 고유 ID'</p>
</blockquote>
<p>즉, 채널의 Url로부터 채널의 고유 ID를 알아내면 채널의 모든 동영상을 재생시켜주는 재생목록의 Url도 알 수 있다.</p>
<p>2.2.2. 로부터 재생목록의 Url이 어떻게 구성되었는지 상기해보자.</p>
<p>그러면 UC + '채널의 고유 ID' 라는 문자열이 재생목록의 고유 ID 라고 가정 후 <a href="https://www.youtube.com/playlist?list=">https://www.youtube.com/playlist?list=</a> 의 뒤에 이 값을 넣는다면 채널의 모든 동영상이 저장된 재생목록으로 이동하는 Url을 찾을 수 있을 것이다.</p>
<p>이것을 위의 세가지 예시에 적용하게 되면,</p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\4.png" alt="4"></p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\5.png" alt="5"></p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\6.png" alt="6"></p>
<p>모두 원하는 재생목록이 나왔음을 알 수 있다. 이제 이 재생목록을 다운로드 받는다면, 채널의 모든 동영상을 다운로드 받을 수 있는 것이다.</p>
<h3 id="23-%ec%bd%94%eb%93%9c-%ec%84%a4%eb%aa%85">2.3. 코드 설명</h3>
<h4 id="231-main-class">2.3.1. Main Class</h4>
<p>main Class 는 사용자로부터 Url을 입력받고 GetUrl 클래스를 불러오는데 사용한다.</p>
<pre><code class="language-python"><div><span class="hljs-keyword">from</span> getUrl <span class="hljs-keyword">import</span> GetUrl


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputUrl</span><span class="hljs-params">()</span>:</span>
    url = GetUrl(input(<span class="hljs-string">'Input URL&gt;&gt; '</span>))

inputUrl()

</div></code></pre>
<h4 id="232-geturl-class">2.3.2. GetUrl Class</h4>
<pre><code class="language-python"><div><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup <span class="hljs-keyword">as</span> bs
<span class="hljs-keyword">from</span> download <span class="hljs-keyword">import</span> Download
<span class="hljs-keyword">import</span> youtube_dl


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUrl</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-comment"># main class로부터 입력된 재생목록의 url을 받아옵니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, Url)</span>:</span>
        urlList = []
        <span class="hljs-comment"># 'https://www.youtube.com/playlist?list=PLwpDa9WrkRDRXRidbaSoWaXecj1BzFIbJ' 와 같은경우</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">'list'</span> <span class="hljs-keyword">in</span> Url.split(<span class="hljs-string">'.com/'</span>)[<span class="hljs-number">-1</span>]:
            self.playListUrl = Url
            self.urlList = self.findUrlFromPlaylist()
            self.down()

        <span class="hljs-comment"># 'https://www.youtube.com/channel/UCd4FmcWIVdWAy0-Q8OJBloQ' 와 같은경우</span>
        <span class="hljs-keyword">elif</span> <span class="hljs-string">'channel'</span> <span class="hljs-keyword">in</span> Url.split(<span class="hljs-string">'.com/'</span>)[<span class="hljs-number">-1</span>]:
            self.channelUrl = Url
            self.findUrlFromChannel()
            self.urlList = self.findUrlFromPlaylist()
            self.down()

        <span class="hljs-comment"># 'https://www.youtube.com/user/SMTOWN' 과 같은경우</span>
        <span class="hljs-keyword">elif</span> <span class="hljs-string">'user'</span> <span class="hljs-keyword">in</span> Url.split(<span class="hljs-string">'.com/'</span>)[<span class="hljs-number">-1</span>]:
            self.userUrl = Url
            self.findUrlFromUser()
            self.urlList = self.findUrlFromPlaylist()
            self.down()

        <span class="hljs-comment"># 일반적인 동영상인 경우</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">with</span> youtube_dl.YoutubeDL({}) <span class="hljs-keyword">as</span> ydl:
                ydl.download([Url])

    <span class="hljs-comment"># 재생목록에 있는 동영상들의 정보를 받아옵니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUrlFromPlaylist</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># playListUrl의 html정보를 읽어옵니다.</span>
        html = requests.get(self.playListUrl)
        soup = bs(html.text, <span class="hljs-string">'html.parser'</span>)
        html.close()

        <span class="hljs-comment"># 동영상들의 제목과 url을 추출합니다.</span>
        videoTitle = soup.findAll(<span class="hljs-string">'tr'</span>, {<span class="hljs-string">'class'</span>: <span class="hljs-string">'pl-video yt-uix-tile'</span>})
        videoLinks = soup.findAll(<span class="hljs-string">'a'</span>, {<span class="hljs-string">'class'</span>: <span class="hljs-string">'pl-video-title-link '</span>
                                                 <span class="hljs-string">'yt-uix-tile-link yt-uix-sessionlink spf-link'</span>})

        <span class="hljs-comment"># 재생목록이 비어있거나 비공개로 설정된 경우</span>
        <span class="hljs-keyword">if</span> len(videoTitle) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> len(videoLinks) == <span class="hljs-number">0</span>:
            print(<span class="hljs-string">'재생목록이 비어있거나 비공개로 설정되어 있습니다.'</span>)
            print(<span class="hljs-string">'실행을 종료합니다.'</span>)
            exit(<span class="hljs-number">0</span>)

        <span class="hljs-comment"># 정상적으로 불러온 경우</span>
        <span class="hljs-keyword">try</span>:
            titleList = []
            urlList = []
            <span class="hljs-comment"># print('제목 추출중...')</span>
            <span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> videoTitle:
                YTtitle = title.get(<span class="hljs-string">'data-title'</span>)
                titleList.append(YTtitle)
                <span class="hljs-comment"># print(YTtitle)</span>
            <span class="hljs-comment"># print('url 추출중...\n')</span>
            <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> videoLinks:
                <span class="hljs-comment"># 재생목록의 정보가 담긴내용은 삭제한 후, 순수한 동영상의 링크만을 가져옵니다.</span>
                <span class="hljs-comment"># 즉, https://www.youtube.com/watch?v=eGXJs7zOHC4&amp;list=PLwpDa9WrkRDRXRidbaSoWaXecj1BzFIbJ&amp;index=2&amp;t=0s</span>
                <span class="hljs-comment"># 에서 https://www.youtube.com/watch?v=eGXJs7zOHC4 만을 split 함수를 통해 추출합니다.</span>
                <span class="hljs-comment"># print(link.get('href').split('&amp;')[0]) (i.e. /watch?v=gb1tnmgPEFo)</span>
                YTurl = <span class="hljs-string">'https://www.youtube.com'</span> + link.get(<span class="hljs-string">'href'</span>).split(<span class="hljs-string">'&amp;'</span>)[<span class="hljs-number">0</span>]
                urlList.append(YTurl)
                <span class="hljs-comment"># print(YTurl)</span>

            <span class="hljs-keyword">for</span> num, i <span class="hljs-keyword">in</span> enumerate(range(len(titleList))):
                print(<span class="hljs-string">'#'</span> + str(num + <span class="hljs-number">1</span>), titleList[i], <span class="hljs-string">':'</span>, urlList[i])

        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            print(e)

        <span class="hljs-keyword">return</span> urlList

    <span class="hljs-comment"># 원하는 채널의 영상의 정보를 모두 가져옵니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUrlFromChannel</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># 채널 Url로부터 채널 ID를 추출합니다.</span>
        channelID = self.channelUrl.split(<span class="hljs-string">'channel/'</span>)[<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>:]  <span class="hljs-comment"># tckgmUcpzqGnzcs7xEqMzQ</span>
        playListID = <span class="hljs-string">'UU'</span> + channelID  <span class="hljs-comment"># UUtckgmUcpzqGnzcs7xEqMzQ</span>

        playAllVideosUrl = <span class="hljs-string">'https://www.youtube.com/playlist?list='</span> + playListID
        self.playListUrl = playAllVideosUrl
        <span class="hljs-comment"># print(self.playListUrl)  # https://www.youtube.com/playlist?list=UUtckgmUcpzqGnzcs7xEqMzQ</span>
        <span class="hljs-comment"># # https://www.youtube.com/watch?v=Ja0ioh5l3Y0 로부터 /watch?v=Ja0ioh5l3Y0 만 추출합니다.</span>
        <span class="hljs-comment"># firstVideoID = self.findUrlFromPlaylist()[0].split('.com')[-1]</span>
        <span class="hljs-comment"># # print(firstVideoID)</span>
        <span class="hljs-comment"># realURL = 'https://www.youtube.com' + firstVideoID + '&amp;list=' + playListID</span>
        <span class="hljs-comment"># print(realURL)  # https://www.youtube.com/watch?v=Ja0ioh5l3Y0&amp;list=UUtckgmUcpzqGnzcs7xEqMzQ</span>

    <span class="hljs-comment"># 원하는 채널의 영상의 정보를 모두 가져옵니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUrlFromUser</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># userUrl의 html정보를 읽어옵니다.</span>
        html = requests.get(self.userUrl)
        soup = bs(html.text, <span class="hljs-string">'html.parser'</span>)
        html.close()

        <span class="hljs-comment"># '모두 재생' 버튼에 담긴 정보를 가져옵니다.</span>
        userLinks = soup.findAll(<span class="hljs-string">'a'</span>, {<span class="hljs-string">'class'</span>: <span class="hljs-string">'yt-uix-sessionlink yt-user-name spf-link'</span>})
        <span class="hljs-comment"># print(userLinks)</span>

        <span class="hljs-comment"># 맨앞의 href 만 필요하기 때문에 iterator 인 userLinks 에 반복문을 적용하지 않고</span>
        <span class="hljs-comment"># 다음과 같이 userLinks.__iter__().__next__() 를 사용하여 첫번째로 나오는 부분만 추출합니다.</span>

        <span class="hljs-comment"># print(userLinks.__iter__().__next__().get('href'))  # /channel/UCaO6TYtlC8U5ttz62hTrZgg</span>

        <span class="hljs-comment"># 마찬가지로 UC xxxx의 형태를 추출하기 위해</span>
        userID = userLinks.__iter__().__next__().get(<span class="hljs-string">'href'</span>).split(<span class="hljs-string">'channel/'</span>)[<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>:]
        playListID = <span class="hljs-string">'UU'</span> + userID
        playAllVideosUrl = <span class="hljs-string">'https://www.youtube.com/playlist?list='</span> + playListID
        self.playListUrl = playAllVideosUrl
        <span class="hljs-comment"># print(self.playListUrl) # 재생목록 링크</span>

    <span class="hljs-comment"># Download 클래스로부터 urlList 안의 url들에대해 일괄적으로 다운로드를 시작합니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">down</span><span class="hljs-params">(self)</span>:</span>
        down = Download(self.urlList)
        down.multiDown()

</div></code></pre>
<h4 id="233-download-class">2.3.3. Download Class</h4>
<pre><code class="language-python"><div><span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> shutil
<span class="hljs-keyword">import</span> youtube_dl


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, url)</span>:</span>
        self.url = url

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multiDown</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># 다운로드 될 폴더의 이름을 현재 시간을 바탕으로 가져옵니다.</span>
        d = datetime.datetime.today()
        newFolderName = <span class="hljs-string">"{:02d}{:02d}{:02d}_{:02d}{:02d}{:02d}"</span>.format(d.year, d.month, d.day, d.hour, d.minute,
                                                                       d.second)
        <span class="hljs-comment"># print(type(newFolderName))  # str인지 확인</span>
        <span class="hljs-comment"># print(newFolderName)  # 정상 출력 확인</span>

        <span class="hljs-comment"># 폴더를 만들기 전 이름이 중복되는지 확인합니다.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(newFolderName):
            os.mkdir(newFolderName)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">'같은 이름의 폴더가 이미 존재합니다.'</span>)
            exit(<span class="hljs-number">0</span>)

        <span class="hljs-comment"># 각각의 url마다 다운로드를 시작합니다.</span>
        <span class="hljs-keyword">for</span> num, url <span class="hljs-keyword">in</span> enumerate(self.url):
            <span class="hljs-comment"># youtube_dl options</span>
            ydl_opts = {
                <span class="hljs-comment"># 'format': 'best/best',  # 가장 좋은 화질로 선택(화질을 선택하여 다운로드 가능)</span>
                <span class="hljs-comment"># 'outtmpl': self.path  # 다운로드 경로 설정 (환경변수 설정 문제로 인하여 설정 불가)</span>
                <span class="hljs-comment"># 'writesubtitles': 'best',  # 자막 다운로드(자막이 없는 경우 다운로드 X)</span>
                <span class="hljs-comment"># 'writethumbnail': 'best',  # 영상 thumbnail 다운로드</span>
                <span class="hljs-comment"># 'writeautomaticsub': True,  # 자동 생성된 자막 다운로드</span>
                <span class="hljs-comment"># 'subtitleslangs': 'en'  # 자막 언어가 영어인 경우(다른 언어로 변경 가능)</span>
            }
            <span class="hljs-keyword">try</span>:
                <span class="hljs-comment"># 다운로드 진행 상태를 출력합니다.</span>
                print(num + <span class="hljs-number">1</span>, <span class="hljs-string">'of'</span>, str(len(self.url)), <span class="hljs-string">'downloading'</span>)
                <span class="hljs-keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="hljs-keyword">as</span> ydl:
                    ydl.download([url])

            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                print(e)

        <span class="hljs-comment"># 다운로드가 끝난 mp4 파일을 지정된 폴더로 이동합니다.</span>
        file = os.listdir(<span class="hljs-string">'.\\'</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> file:
            temp = i.split(<span class="hljs-string">'.'</span>)
            <span class="hljs-keyword">if</span> temp[<span class="hljs-number">-1</span>].lower() == <span class="hljs-string">'mp4'</span>:
                shutil.move(<span class="hljs-string">'.\\'</span> + i, <span class="hljs-string">'.\\'</span> + newFolderName + <span class="hljs-string">'\\'</span> + i)

</div></code></pre>
<h2 id="3-%ed%86%a0%ec%9d%98">3. 토의</h2>
<h3 id="31-%ec%bd%94%eb%93%9c-%ec%9e%91%ec%84%b1-%ec%a4%91-%eb%b0%9c%ec%83%9d%ed%96%88%eb%8d%98-%ec%97%90%eb%9f%ac-%eb%b6%84%ec%84%9d">3.1. 코드 작성 중 발생했던 에러 분석</h3>
<ol>
<li>AttributeError: 'GetUrl' object has no attribute 'urlList'</li>
</ol>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\9.png" alt="9"></p>
<p>다음의 부분에서 highlighted 된 부분의 코드를 작성하지 않아서 에러가 발생했다.</p>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\8.png" alt="8"></p>
<p>findUrlFromUser() 메소드에서 self.playListUrl 의 값을 지정해주면 해당 채널의 모든 동영상이 담긴 재생목록의 Url을 받아올 수 있는데,</p>
<p>이 재생목록으로부터 동영상들의 Url이 담긴 list를 받아오지 않고 down()메소드를 실행했다. down() 메소드는 self.urlList 에 저장된 동영상 list 들의 url 을 바탕으로 다운로드를 실행하는 메소드인데, 이 list의 값이 초기화가 안되어있는 채로 (None) calling 해버렸기 때문에 결국 에러가 발생했다.</p>
<p>그래서 self.urlList의 값을 재생목록의 Url로부터 동영상들의 리스트를 반환하는 findUrlFromPlayList() 메소드로 self.urlList의 값을 할당 해주고, 다시 확인해보니 정상적으로 작동되었다.</p>
<ol start="2">
<li>
<p>TypeError: expected string or bytes-like object</p>
<p>현재 시간을 바탕으로 저장될 폴더이름을 만들 때, datetime 모듈로부터 불러온 날짜/시간정보가 str type가 아닌채로 makedir 메소드를 실행시켜서 발생했다.</p>
<p>불러온 시간정보를 str() 을 이용하여 type casting 하고 실행하니 정상 작동 하였다.</p>
</li>
<li>
<p>재생목록의 동영상이 100개를 초과하는 경우</p>
<p>다음의 사진과 같이 유튜브에서는 자체적으로 메모리를 절약하기 위해서 재생목록의 모든 영상을 불러오지 않고, 상위 100개만 html에 포함시킨다.</p>
</li>
</ol>
<p><img src="file:///c:\Users\HS YUN\Downloads\Github\Python_AutomationClass_Project\image\10.png" alt="10"></p>
<p>사용자가 100번째 영상까지 스크롤을 내리면 유튜브는 동영상을 다시 로드하는데, 문제는 html을 가져올 때 이것이 로드되지 않은채로 html을 가져오기 때문에  최대로 다운로드 받을 수 있는 동영상의 개수가 100개로 제한 되어있다.</p>
<p>문제를 해결할 수 있는 방법은 찾았지만 이는 3.2.1. 에서 설명한다.</p>
<h3 id="32-%ec%b6%94%ea%b0%80-%ed%99%9c%ec%9a%a9-%eb%b0%a9%ec%95%88">3.2. 추가 활용 방안</h3>
<p>다음의 내용들은 추가적으로 구현 해 볼 만한 기능 이였지만, 보고서 제출 기한이 앞당겨져서 구현하지 못한 내용들을 다룬다.</p>
<h4 id="321-selenium-%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%98%ec%97%ac-100%ea%b0%9c-%ec%9d%b4%ec%83%81%ec%9d%98-%eb%8f%99%ec%98%81%ec%83%81%ec%9d%84-%eb%8b%a4%ec%9a%b4%eb%a1%9c%eb%93%9c-%ed%95%a0-%ec%88%98-%ec%9e%88%ea%b2%8c%ed%95%98%ea%b8%b0">3.2.1. selenium 라이브러리를 이용하여 100개 이상의 동영상을 다운로드 할 수 있게하기</h4>
<p>selenium 라이브러리는 스스로 인터넷 창을 열어 원하는 기능을 자동으로 제어 할 수 있는 기능을 제공한다.</p>
<p>위에서 말했듯이 100개 이상의 동영상의 Url을 얻기 위해 selenium 으로 101번째 부터의 동영상을 로드하도록 제어한 다음, 이를 다시 beautifulSoup 라이브러리로 동영상 정보를 얻어내어 다운로드 하면 구현할 수 있을 것 이다.</p>
<h4 id="322-%eb%8b%a4%ec%9a%b4%eb%a1%9c%eb%93%9c-%eb%b0%9b%ec%9d%80-mp4-%ed%8c%8c%ec%9d%bc%ec%9d%84-mp3%ec%9c%bc%eb%a1%9c-%eb%b3%80%ed%99%98%ed%95%b4%ec%a3%bc%eb%8a%94-%ea%b8%b0%eb%8a%a5">3.2.2. 다운로드 받은 .mp4 파일을 .mp3으로 변환해주는 기능</h4>
<p>moviepy 라는 라이브러리를 이용하여 동영상 파일을 음악 파일로 변환 시킬 수 있다.</p>
<h3 id="33-%ec%97%ac%eb%8b%b4">3.3. 여담</h3>
<p>사실 youtube-dl 모듈 하나만으로도 위의 기능을 모두 구현 할 수 있다. 하지만 배운 내용들을 최대한 활용하여 직접 만들어 보는 것이 의미가 있기에 새로 코드를 작성해 보았다.</p>

    </body>
    </html>